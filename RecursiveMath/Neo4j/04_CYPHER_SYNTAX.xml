<?xml version="1.0" encoding="UTF-8"?>
<cypher_syntax_guide>
    <metadata>
        <document_id>CYPHER</document_id>
        <file>04_CYPHER_SYNTAX.xml</file>
        <references>
            <ref>00_MASTER_INDEX.xml</ref>
            <ref>02_NAVIGATION_QUERIES.xml</ref>
        </references>
        <critical_rule>EVERY query MUST start with "CYPHER 25"</critical_rule>
    </metadata>

    <working_patterns>
        <pattern id="P001" name="Basic_Node_Query">
            <syntax><![CDATA[
CYPHER 25
MATCH (n:NodeLabel {property: 'value', namespace: 'recursive_math'})
RETURN n
            ]]></syntax>
            <note>Always include namespace in queries</note>
        </pattern>

        <pattern id="P002" name="Create_Node_With_UUID">
            <syntax><![CDATA[
CYPHER 25
MERGE (n:NodeLabel {
    name: 'unique_name',
    namespace: 'recursive_math',
    id: randomUUID()
})
SET n.property = value
RETURN n
            ]]></syntax>
            <note>Use randomUUID() for unique identifiers</note>
        </pattern>

        <pattern id="P003" name="Optional_Match_Pattern">
            <syntax><![CDATA[
CYPHER 25
MATCH (n:NodeLabel {namespace: 'recursive_math'})
OPTIONAL MATCH (n)-[r]->(m)
RETURN n, r, m
            ]]></syntax>
            <note>OPTIONAL MATCH prevents null results</note>
        </pattern>

        <pattern id="P004" name="Null_Handling">
            <syntax><![CDATA[
CYPHER 25
MATCH (n)
RETURN coalesce(n.property, 'default') as value
            ]]></syntax>
            <note>Use coalesce() for nullable fields</note>
        </pattern>

        <pattern id="P005" name="String_Filtering">
            <correct><![CDATA[
CYPHER 25
MATCH (n)
WHERE n.property STARTS WITH 'prefix'
RETURN n
            ]]></correct>
            <incorrect><![CDATA[
WHERE n.property =~ 'prefix.*'  // Don't use regex for simple prefix
            ]]></incorrect>
        </pattern>

        <pattern id="P006" name="Aggregation_Pattern">
            <syntax><![CDATA[
CYPHER 25
MATCH (n:NodeLabel {namespace: 'recursive_math'})
RETURN labels(n)[0] as type, count(n) as count
ORDER BY count DESC
            ]]></syntax>
        </pattern>

        <pattern id="P007" name="Relationship_Creation">
            <syntax><![CDATA[
CYPHER 25
MATCH (from:NodeLabel {name: 'source', namespace: 'recursive_math'})
MATCH (to:NodeLabel {name: 'target', namespace: 'recursive_math'})
MERGE (from)-[:RELATIONSHIP_TYPE]->(to)
RETURN from, to
            ]]></syntax>
        </pattern>

        <pattern id="P008" name="Collect_Pattern">
            <syntax><![CDATA[
CYPHER 25
MATCH (n:NodeLabel {namespace: 'recursive_math'})
RETURN collect(DISTINCT n.property) as properties
            ]]></syntax>
        </pattern>

        <pattern id="P009" name="WITH_Clause_Chaining">
            <syntax><![CDATA[
CYPHER 25
MATCH (n:NodeLabel {namespace: 'recursive_math'})
WITH n, count(n) as cnt
WHERE cnt > 1
RETURN n, cnt
            ]]></syntax>
            <note>WITH preserves context between query sections</note>
        </pattern>

        <pattern id="P010" name="Delete_Duplicates">
            <syntax><![CDATA[
CYPHER 25
MATCH (n:NodeLabel {namespace: 'recursive_math'})
WITH n.name as name, collect(n) as nodes
WHERE size(nodes) > 1
FOREACH (i IN range(1, size(nodes)-1) | DETACH DELETE nodes[i])
RETURN count(*) as deleted
            ]]></syntax>
        </pattern>
    </working_patterns>

    <common_errors>
        <error id="E001">
            <problem>Multiple statements in one query</problem>
            <solution>Execute each CREATE INDEX separately</solution>
        </error>

        <error id="E002">
            <problem>Missing CYPHER 25 prefix</problem>
            <solution>Always start with CYPHER 25</solution>
        </error>

        <error id="E003">
            <problem>Type mismatch with special characters</problem>
            <solution>Use ASCII names internally, store Unicode in properties</solution>
        </error>

        <error id="E004">
            <problem>Null pointer in aggregation</problem>
            <solution>Use OPTIONAL MATCH and coalesce()</solution>
        </error>
    </common_errors>

    <namespace_queries>
        <query name="Check_Namespace_Exists">
            <cypher><![CDATA[
CYPHER 25
MATCH (ns:Namespace {name: 'recursive_math'})
RETURN ns
            ]]></cypher>
        </query>

        <query name="Count_Namespace_Nodes">
            <cypher><![CDATA[
CYPHER 25
MATCH (n) 
WHERE n.namespace = 'recursive_math'
RETURN count(n) as total
            ]]></cypher>
        </query>

        <query name="Clean_Namespace">
            <cypher><![CDATA[
CYPHER 25
MATCH (n) 
WHERE n.namespace = 'recursive_math'
DETACH DELETE n
            ]]></cypher>
            <warning>This deletes everything in namespace!</warning>
        </query>
    </namespace_queries>

    <best_practices>
        <practice>Always use namespace filtering</practice>
        <practice>Include randomUUID() for new nodes</practice>
        <practice>Use MERGE to prevent duplicates</practice>
        <practice>Handle nulls with coalesce()</practice>
        <practice>Use OPTIONAL MATCH for potentially missing relationships</practice>
        <practice>Return meaningful property names</practice>
        <practice>Order results for consistency</practice>
    </best_practices>
</cypher_syntax_guide>