<?xml version="1.0" encoding="UTF-8"?>
<worked_examples>
    <metadata>
        <document_id>EXAMPLES</document_id>
        <file>08_WORKED_EXAMPLES.xml</file>
        <references>
            <ref>00_MASTER_INDEX.xml</ref>
            <ref>07_THEORY_SUMMARY.xml</ref>
            <ref>09_NOTATION_GUIDE.xml</ref>
        </references>
    </metadata>

    <example id="EX001" name="Computing_Sqrt2">
        <problem>Compute √2 using recursive mathematics</problem>
        
        <step n="1">
            <action>Define √2</action>
            <notation>√2 ≝ {x: x² = 2}</notation>
            <note>This defines but doesn't claim existence</note>
        </step>
        
        <step n="2">
            <action>Note non-existence</action>
            <notation>√2 ∄ in ℚ</notation>
            <note>Classical proof: if √2 = p/q in lowest terms, contradiction</note>
        </step>
        
        <step n="3">
            <action>Create generator</action>
            <notation>⟨n: Newton(1, n)⟩</notation>
            <formula>Newton(x, 0) = x; Newton(x, k+1) = (Newton(x,k) + 2/Newton(x,k))/2</formula>
        </step>
        
        <step n="4">
            <action>Compute approximations</action>
            <calculations>
                <level n="0">√2 ≈_0 1/1 = 1.000000</level>
                <level n="1">√2 ≈_1 3/2 = 1.500000</level>
                <level n="2">√2 ≈_2 17/12 = 1.416667</level>
                <level n="3">√2 ≈_3 577/408 = 1.414216</level>
                <level n="4">√2 ≈_4 665857/470832 = 1.414214</level>
            </calculations>
        </step>
        
        <verification>
            <check>(577/408)² = 332929/166464 = 2.000006...</check>
            <error>Error at level 3: 0.0003%</error>
        </verification>
        
        <conclusion>All computation stays in ℚ, achieving arbitrary precision</conclusion>
    </example>

    <example id="EX002" name="Computing_Pi">
        <problem>Compute π using Leibniz series</problem>
        
        <step n="1">
            <action>Define π</action>
            <notation>π ≝ ratio of circumference to diameter</notation>
        </step>
        
        <step n="2">
            <action>Generator using Leibniz</action>
            <notation>⟨n: 4·Σ((-1)^k/(2k+1), k=0..n)⟩</notation>
        </step>
        
        <step n="3">
            <action>Compute terms</action>
            <calculations>
                <level n="0">π ≈_0 4·(1) = 4/1</level>
                <level n="1">π ≈_1 4·(1 - 1/3) = 8/3</level>
                <level n="2">π ≈_2 4·(1 - 1/3 + 1/5) = 52/15</level>
                <level n="3">π ≈_3 4·(1 - 1/3 + 1/5 - 1/7) = 304/105</level>
            </calculations>
        </step>
        
        <better_method>
            <name>Machin Formula</name>
            <formula>π = 16·arctan(1/5) - 4·arctan(1/239)</formula>
            <convergence>Much faster: each term adds multiple digits</convergence>
            <approximation>π ≈_3 355/113 (accurate to 6 decimals)</approximation>
        </better_method>
    </example>

    <example id="EX003" name="Computing_e">
        <problem>Compute Euler's number e</problem>
        
        <step n="1">
            <action>Define e</action>
            <notation>e ≝ lim_{n→∞} (1 + 1/n)^n</notation>
            <alternative>e ≝ Σ(1/k!, k=0..∞)</alternative>
        </step>
        
        <step n="2">
            <action>Factorial series generator</action>
            <notation>⟨n: Σ(1/k!, k=0..n)⟩</notation>
        </step>
        
        <step n="3">
            <action>Compute terms</action>
            <calculations>
                <level n="0">e ≈_0 1/1</level>
                <level n="1">e ≈_1 1 + 1 = 2/1</level>
                <level n="2">e ≈_2 2 + 1/2 = 5/2</level>
                <level n="3">e ≈_3 5/2 + 1/6 = 16/6 = 8/3</level>
                <level n="4">e ≈_4 8/3 + 1/24 = 65/24</level>
                <level n="5">e ≈_5 65/24 + 1/120 = 163/60</level>
                <level n="6">e ≈_6 163/60 + 1/720 = 1957/720</level>
            </calculations>
        </step>
        
        <convergence>
            <rate>Factorial - extremely fast</rate>
            <accuracy>Level 6 gives 8 correct decimals</accuracy>
        </convergence>
    </example>

    <example id="EX004" name="Continued_Fractions">
        <problem>Express golden ratio φ as continued fraction</problem>
        
        <step n="1">
            <action>Define φ</action>
            <notation>φ ≝ {x: x² = x + 1}</notation>
            <algebraic>φ = (1 + √5)/2</algebraic>
        </step>
        
        <step n="2">
            <action>Continued fraction form</action>
            <notation>φ = [1; 1, 1, 1, ...]</notation>
            <meaning>φ = 1 + 1/(1 + 1/(1 + 1/(1 + ...)))</meaning>
        </step>
        
        <step n="3">
            <action>Convergents are Fibonacci ratios</action>
            <calculations>
                <level n="0">1/1</level>
                <level n="1">2/1</level>
                <level n="2">3/2</level>
                <level n="3">5/3</level>
                <level n="4">8/5</level>
                <level n="5">13/8</level>
                <level n="6">21/13</level>
            </calculations>
            <pattern>F_{n+1}/F_n where F_n is Fibonacci</pattern>
        </step>
    </example>

    <example id="EX005" name="Resolving_Zeno">
        <problem>Resolve Zeno's paradox using discrete space</problem>
        
        <classical_paradox>
            To travel distance d, must first travel d/2, then d/4, then d/8...
            Infinite steps required!
        </classical_paradox>
        
        <recursive_resolution>
            <fact>Space is discrete at Planck scale: ℓ_P = 10^-35 m</fact>
            <calculation>
                For d = 1 meter:
                Number of Planck lengths = 10^35
                This is finite!
            </calculation>
            <step_sequence>
                <s>First half: 5×10^34 Planck lengths</s>
                <s>Next quarter: 2.5×10^34 Planck lengths</s>
                <s>Continue until reaching single Planck length</s>
                <s>Total steps: finite (approximately 116 halvings)</s>
            </step_sequence>
        </recursive_resolution>
        
        <conclusion>Motion requires only finite steps in discrete space</conclusion>
    </example>

    <proof_example id="PR001" name="No_Incompleteness">
        <theorem>Gödel's incompleteness vanishes in recursive mathematics</theorem>
        
        <classical_godel>
            In any consistent formal system F containing arithmetic,
            there exists statement G such that:
            - If F is consistent, G is true but unprovable in F
        </classical_godel>
        
        <recursive_argument>
            <step n="1">
                <claim>G typically asserts "This statement is unprovable"</claim>
                <issue>This makes existence claim about proof</issue>
            </step>
            
            <step n="2">
                <claim>In recursive math, we never claim existence</claim>
                <only>We only define and approximate</only>
            </step>
            
            <step n="3">
                <claim>G becomes: "This statement is defined as unprovable"</claim>
                <status>This is just a definition, not a truth claim</status>
            </step>
            
            <step n="4">
                <claim>No paradox arises from definitions</claim>
                <reason>Can't have true-but-unprovable without existence claims</reason>
            </step>
        </recursive_argument>
        
        <conclusion>
            Incompleteness requires existence claims we don't make
        </conclusion>
    </proof_example>

    <programming_example id="PG001">
        <language>Python</language>
        <code><![CDATA[
from fractions import Fraction

class RecursiveGenerator:
    def __init__(self, name, formula):
        self.name = name
        self.formula = formula
    
    def at_level(self, n):
        """Return rational approximation at level n"""
        return self.formula(n)

# Define sqrt(2) generator
def newton_sqrt2(n):
    x = Fraction(1, 1)
    for _ in range(n):
        x = (x + Fraction(2) / x) / 2
    return x

sqrt2 = RecursiveGenerator("sqrt(2)", newton_sqrt2)

# Compute approximations
for level in range(5):
    approx = sqrt2.at_level(level)
    error = abs(float(approx)**2 - 2)
    print(f"√2 ≈_{level} {approx} = {float(approx):.6f}, error: {error:.9f}")
        ]]></code>
        
        <output>
√2 ≈_0 1/1 = 1.000000, error: 1.000000000
√2 ≈_1 3/2 = 1.500000, error: 0.250000000
√2 ≈_2 17/12 = 1.416667, error: 0.006944444
√2 ≈_3 577/408 = 1.414216, error: 0.000006007
√2 ≈_4 665857/470832 = 1.414214, error: 0.000000005
        </output>
    </programming_example>
</worked_examples>