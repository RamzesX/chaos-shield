<?xml version="1.0" encoding="UTF-8"?>
<ConvQ_Computations>
    <metadata>
        <purpose>Concrete computational examples in Conv(ℚ)</purpose>
        <usage>Include throughout essays to show practical implementation</usage>
        <note>All computations use only rational arithmetic</note>
    </metadata>

    <!-- Basic Computations -->
    <computation_group id="basic">
        <computation id="sqrt2">
            <n>Computing √2 via Newton's Method</n>
            <algorithm>
                x₀ = 1
                x_{n+1} = (x_n + 2/x_n)/2
            </algorithm>
            <sequence>
                x₀ = 1
                x₁ = 3/2 = 1.5
                x₂ = 17/12 = 1.41666...
                x₃ = 577/408 = 1.41421568...
                x₄ = 665857/470832
            </sequence>
            <convergence>Quadratic: |x_{n+1} - x_n| &lt; 1/2^{2^n}</convergence>
        </computation>

        <computation id="pi">
            <n>Computing π via Machin's Formula</n>
            <formula>π/4 = 4·arctan(1/5) - arctan(1/239)</formula>
            <rational_series>
                arctan(x) = x - x³/3 + x⁵/5 - x⁷/7 + ...
                All coefficients rational!
            </rational_series>
            <precision>14 digits with just 10 terms</precision>
        </computation>

        <computation id="e">
            <n>Computing e via Taylor Series</n>
            <series>e = Σ_{n=0}^∞ 1/n!</series>
            <partial_sums>
                S₀ = 1
                S₁ = 2
                S₂ = 5/2 = 2.5
                S₃ = 8/3 = 2.666...
                S₄ = 65/24 = 2.70833...
                S₅ = 163/60 = 2.71666...
            </partial_sums>
            <rate>Factorial convergence - extremely fast</rate>
        </computation>
    </computation_group>

    <!-- Neural Networks -->
    <computation_group id="neural">
        <computation id="backprop">
            <n>Neural Network Training in ℚ</n>
            <gradient_descent>
                W^{(n+1)} = W^{(n)} - η∇L
                All operations in ℚ when W^{(0)} ∈ ℚ and η ∈ ℚ
            </gradient_descent>
            <activation>ReLU(x) = max(0,x) preserves ℚ</activation>
            <loss>L = Σ(y_i - ŷ_i)² ∈ ℚ for rational data</loss>
            <example>
                2-layer network: all weights stay rational
                Training preserves ℚ throughout
            </example>
        </computation>

        <computation id="convolution">
            <n>Convolution in ℚ</n>
            <discrete>(f * g)[n] = Σ_m f[m]g[n-m]</discrete>
            <property>ℚ-valued signals stay in ℚ</property>
        </computation>
    </computation_group>

    <!-- Information Theory -->
    <computation_group id="information">
        <computation id="entropy">
            <n>Shannon Entropy Computation</n>
            <formula>H = -Σ p_i log₂(p_i)</formula>
            <rational_approx>
                For p_i ∈ ℚ, use: log₂(p/q) = log₂(p) - log₂(q)
                where log₂ computed via rational series
            </rational_approx>
            <example>
                Fair coin: H = -2·(1/2)log₂(1/2) = 1 bit exactly
                Biased coin (1/3, 2/3): H ∈ ℚ[log₂(2), log₂(3)]
            </example>
        </computation>

        <computation id="compression">
            <n>Huffman Coding in ℚ</n>
            <property>All probabilities rational ⟹ all code lengths rational</property>
            <average_length>L = Σ p_i l_i ∈ ℚ</average_length>
        </computation>
    </computation_group>

    <!-- Cryptography -->
    <computation_group id="crypto">
        <computation id="rsa">
            <n>RSA with ℚ-integers</n>
            <key_generation>
                p, q = large primes ∈ ℚ
                n = pq (617 digits for RSA-2048)
                φ(n) = (p-1)(q-1) ∈ ℚ
                e = 65537 (common choice)
                d ≡ e^{-1} (mod φ(n)) via extended Euclidean
            </key_generation>
            <encryption>c ≡ m^e (mod n), all in ℚ</encryption>
            <security>Based on difficulty of factoring in ℚ</security>
        </computation>

        <computation id="elliptic">
            <n>Elliptic Curves over ℚ</n>
            <curve>y² = x³ + ax + b, a,b ∈ ℚ</curve>
            <group_law>Chord-tangent method gives ℚ-points</group_law>
            <example>
                P = (0,1), Q = (1,2) on y² = x³ + x + 1
                P + Q computed via rational operations
            </example>
        </computation>
    </computation_group>

    <!-- Numerical Methods -->
    <computation_group id="numerical">
        <computation id="integration">
            <n>Numerical Integration in ℚ</n>
            <simpson>
                ∫_a^b f(x)dx ≈ (h/3)[f(a) + 4f((a+b)/2) + f(b)]
                where h = (b-a) ∈ ℚ
            </simpson>
            <property>Rational nodes → rational result</property>
        </computation>

        <computation id="ode">
            <n>Solving ODEs in ℚ</n>
            <euler>
                y_{n+1} = y_n + h·f(t_n, y_n)
                Preserves ℚ when y₀, h ∈ ℚ
            </euler>
            <runge_kutta>RK4 also preserves rationality</runge_kutta>
        </computation>
    </computation_group>

    <implementation_note>
        All these computations can be implemented using only:
        - Integer arithmetic (for numerators/denominators)
        - Basic operations: +, -, ×, ÷
        - No floating point needed!
        - Arbitrary precision via bignum libraries
    </implementation_note>
</ConvQ_Computations>